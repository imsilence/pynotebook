今天周三，依然给大家解答下遗留的作业
我们上周的作业是在已经统计字符串read_me，并打印出现次数前十的字符串
我们在课堂上已经练习了统计每个字符出现的次数，那接下来我们要找到出现次数做多的前十个字符
char_stat_dict = {'a' : 5, 'b' : 9, 'c' : 20, 'd' : 10}
我们来想想假设我们要数量最多的一个元素呢？我们可以定义个max_count, max_count_char
这是不是跟我们之前在找到一个列表中最大的一个数字练习类似，但是我们只定义个max_num来接收最大的值，现在我们定义了两个变量，一个来接收出现最多的次数，一个接收出现最多次数的字母
我们接下来又做了找两个最大的数字的练习，我们后来引入我们要找更多个最大的数字需要使用列表，我们就介绍了list的排序

我们如果从已经从小到大的list中拿到最大的前N个数字是不是特别容易，我们只需要使用切片sorted_list[-1:-N-1:-1]

那对于我们现在的char_stat_dict呢，我们能不能根据出现的次数对他进行排序呢？我们介绍过，dict是一个无序的，我们不能对他进行排序，但是我们介绍过有序的并且可以修改的list，我们可不可以将dict转化为list再进行排序，我们想想dict中可以将dict转化为list的函数，我们来查一下，我们通过dir查询dict的所有函数，我们看到我们学到的items函数，可以将dict转化为list，list的每隔元素为元祖，元祖的第一个元素对应字典中的key，第二个元素对应字典中的value

这时候我们将对dict的排序转化为list的排序
但是我们之前介绍的都是list中的元素是一个数字，我们如何对list中的每个元祖进行排序呢，我们考虑一下，我们之前的排序中，我们只需要比较出list中两个元素的大小就可以了，对不对，那我们是否可以用每个元祖索引的某个的元素比较代表他们的大小呢，比如我们现在就使用索引为1的元素(出现的次数)代表每隔元祖进行比较，当然是可以的
我们用冒泡算法实现一下char_stat_dict的排序

char_stat_list = []
我们把第一最大元素冒泡到最后
for y in in range(len(char_stat_list) - 1):
    for x in range(len(char_stat_list) - 1):
        if char_stat_list[x][1] > char_stat_list[x + 1][1]:
            char_stat_list[x], char_stat_list[x + 1] = char_stat_list[x + 1], char_stat_list[x]

